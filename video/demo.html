<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>One on One Sample</title>
  <!-- sdk源文件git地址：https://github.com/pili-engineering/QNRTC-Web/tree/master/Release/qnweb-rtc.js -->
  <!-- 该地址仅供测试，不保证稳定，正式环境切勿使用 -->
  <script src="./js/qnweb-rtc.js"></script>
  <style>
    select {
      width: 300px;
    }

    section {
      margin-bottom: 20px;
    }

    #localtracks,
    #remotetracks {
      width: 320px;
      height: 240px;
      background: #000;
    }
  </style>
</head>

<body>
  <label>请输入 RoomToken 加入房间开始连麦</label>
  <input id="roomtoken" type="text" />
  <p class="tips">如果您不知道如何生成 RoomToken，查看<a href="https://developer.qiniu.io/rtc/8802/pd-overview"
      target="_black">这里的接入流程</a></p>
  <button onclick="joinRoom()">加入房间</button>
  <p>本地视频</p>
  <div id="localtracks"></div>
  <p>远端视频</p>
  <div id="remotetracks"></div>
</body>

</html>
<script>
  // 确认引入成功
  console.log("current version",QNRTC.VERSION);
  // 这里采用的是 async/await 的异步方案，您也可以根据需要或者习惯替换成 Promise 的写法
  async function joinRoom() {
    // 创建QNRTCClient对象
    const client=QNRTC.createClient();
    // 需要先监听对应事件再加入房间
    autoSubscribe(client);
    const roomTokenInput=document.getElementById("roomtoken");
    const roomToken=roomTokenInput.value;
    // 这里替换成刚刚生成的 RoomToken
    await client.join(roomToken);
    console.log("joinRoom success!");
    await publish(client);
  }
  // 增加一个函数 publish，用于采集并发布自己的媒体流
  // 这里的参数 client 是指刚刚初始化的 QNRTCClient 对象
  async function publish(client) {
    // 同时采集麦克风音频和摄像头视频轨道。
    // 这个函数会返回一组audio track 与 video track

    const localTracks=await QNRTC.createMicrophoneAndCameraTracks();
    console.log("my local tracks",localTracks);
    // 将刚刚的 Track 列表发布到房间中
    await client.publish(localTracks);
    console.log("publish success!");
    // 在这里添加
    // 获取页面上的一个元素作为播放画面的父元素
    const localElement=document.getElementById("localtracks");
    // 遍历本地采集的 Track 对象
    for(const localTrack of localTracks) {
      console.log(localTrack)
      // 如果这是麦克风采集的音频 Track，我们就不播放它。
      if(localTrack.isAudio()) continue;
      // 调用 Track 对象的 play 方法在这个元素下播放视频轨
      localTrack.play(localElement,{
        mirror: true
      });
    }
  }

  // 这里的参数 client 是指刚刚初始化的 QNRTCClient 对象
  async function subscribe(client,tracks) {
    // 传入 Track 对象数组调用订阅方法发起订阅，异步返回成功订阅的 Track 对象。
    const remoteTracks=await client.subscribe(tracks);

    // 选择页面上的一个元素作为父元素，播放远端的音视频轨
    const remoteElement=document.getElementById("remotetracks");
    // 遍历返回的远端 Track，调用 play 方法完成在页面上的播放
    for(const remoteTrack of [...remoteTracks.videoTracks,...remoteTracks.audioTracks]) {
      remoteTrack.play(remoteElement);
    }
  }

  // 这里的参数 client 是指刚刚初始化的 QNRTCClient 对象, 同上
  function autoSubscribe(client) {
    // 添加事件监听，当房间中出现新的 Track 时就会触发，参数是 trackInfo 列表
    client.on("user-published",(userId,tracks) => {
      console.log("user-published!",userId,tracks);
      subscribe(client,tracks)
        .then(() => console.log("subscribe success!"))
        .catch(e => console.error("subscribe error",e));
    });
    // 就是这样，就像监听 DOM 事件一样通过 on 方法监听相应的事件并给出处理函数即可
  }
</script>